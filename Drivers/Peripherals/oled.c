#include "oled.h"
#include "i2c.h"
#include <string.h>
#include "dma.h"
static uint8_t fb[1 + OLED_W * OLED_PAGES];
static volatile uint8_t dma_busy = 0;
/* ── Font 5x8 (ASCII 0x20–0x7E) ─────────────────────────────────────────────
 * 95 characters. Each entry = 5 column bytes.
 * Bit0 of each byte = top pixel, bit7 = bottom pixel.
 */
static const uint8_t font[][5] = {
    {0x00,0x00,0x00,0x00,0x00}, /* ' ' */
    {0x00,0x00,0x5F,0x00,0x00}, /* '!' */
    {0x00,0x07,0x00,0x07,0x00}, /* '"' */
    {0x14,0x7F,0x14,0x7F,0x14}, /* '#' */
    {0x24,0x2A,0x7F,0x2A,0x12}, /* '$' */
    {0x23,0x13,0x08,0x64,0x62}, /* '%' */
    {0x36,0x49,0x55,0x22,0x50}, /* '&' */
    {0x00,0x05,0x03,0x00,0x00}, /* ''' */
    {0x00,0x1C,0x22,0x41,0x00}, /* '(' */
    {0x00,0x41,0x22,0x1C,0x00}, /* ')' */
    {0x14,0x08,0x3E,0x08,0x14}, /* '*' */
    {0x08,0x08,0x3E,0x08,0x08}, /* '+' */
    {0x00,0x50,0x30,0x00,0x00}, /* ',' */
    {0x08,0x08,0x08,0x08,0x08}, /* '-' */
    {0x00,0x60,0x60,0x00,0x00}, /* '.' */
    {0x20,0x10,0x08,0x04,0x02}, /* '/' */
    {0x3E,0x51,0x49,0x45,0x3E}, /* '0' */
    {0x00,0x42,0x7F,0x40,0x00}, /* '1' */
    {0x42,0x61,0x51,0x49,0x46}, /* '2' */
    {0x21,0x41,0x45,0x4B,0x31}, /* '3' */
    {0x18,0x14,0x12,0x7F,0x10}, /* '4' */
    {0x27,0x45,0x45,0x45,0x39}, /* '5' */
    {0x3C,0x4A,0x49,0x49,0x30}, /* '6' */
    {0x01,0x71,0x09,0x05,0x03}, /* '7' */
    {0x36,0x49,0x49,0x49,0x36}, /* '8' */
    {0x06,0x49,0x49,0x29,0x1E}, /* '9' */
    {0x00,0x36,0x36,0x00,0x00}, /* ':' */
    {0x00,0x56,0x36,0x00,0x00}, /* ';' */
    {0x08,0x14,0x22,0x41,0x00}, /* '<' */
    {0x14,0x14,0x14,0x14,0x14}, /* '=' */
    {0x00,0x41,0x22,0x14,0x08}, /* '>' */
    {0x02,0x01,0x51,0x09,0x06}, /* '?' */
    {0x32,0x49,0x79,0x41,0x3E}, /* '@' */
    {0x7E,0x11,0x11,0x11,0x7E}, /* 'A' */
    {0x7F,0x49,0x49,0x49,0x36}, /* 'B' */
    {0x3E,0x41,0x41,0x41,0x22}, /* 'C' */
    {0x7F,0x41,0x41,0x22,0x1C}, /* 'D' */
    {0x7F,0x49,0x49,0x49,0x41}, /* 'E' */
    {0x7F,0x09,0x09,0x09,0x01}, /* 'F' */
    {0x3E,0x41,0x49,0x49,0x7A}, /* 'G' */
    {0x7F,0x08,0x08,0x08,0x7F}, /* 'H' */
    {0x00,0x41,0x7F,0x41,0x00}, /* 'I' */
    {0x20,0x40,0x41,0x3F,0x01}, /* 'J' */
    {0x7F,0x08,0x14,0x22,0x41}, /* 'K' */
    {0x7F,0x40,0x40,0x40,0x40}, /* 'L' */
    {0x7F,0x02,0x04,0x02,0x7F}, /* 'M' */
    {0x7F,0x04,0x08,0x10,0x7F}, /* 'N' */
    {0x3E,0x41,0x41,0x41,0x3E}, /* 'O' */
    {0x7F,0x09,0x09,0x09,0x06}, /* 'P' */
    {0x3E,0x41,0x51,0x21,0x5E}, /* 'Q' */
    {0x7F,0x09,0x19,0x29,0x46}, /* 'R' */
    {0x46,0x49,0x49,0x49,0x31}, /* 'S' */
    {0x01,0x01,0x7F,0x01,0x01}, /* 'T' */
    {0x3F,0x40,0x40,0x40,0x3F}, /* 'U' */
    {0x1F,0x20,0x40,0x20,0x1F}, /* 'V' */
    {0x3F,0x40,0x38,0x40,0x3F}, /* 'W' */
    {0x63,0x14,0x08,0x14,0x63}, /* 'X' */
    {0x07,0x08,0x70,0x08,0x07}, /* 'Y' */
    {0x61,0x51,0x49,0x45,0x43}, /* 'Z' */
    {0x00,0x7F,0x41,0x41,0x00}, /* '[' */
    {0x02,0x04,0x08,0x10,0x20}, /* '\' */
    {0x00,0x41,0x41,0x7F,0x00}, /* ']' */
    {0x04,0x02,0x01,0x02,0x04}, /* '^' */
    {0x40,0x40,0x40,0x40,0x40}, /* '_' */
    {0x00,0x01,0x02,0x04,0x00}, /* '`' */
    {0x20,0x54,0x54,0x54,0x78}, /* 'a' */
    {0x7F,0x48,0x44,0x44,0x38}, /* 'b' */
    {0x38,0x44,0x44,0x44,0x20}, /* 'c' */
    {0x38,0x44,0x44,0x48,0x7F}, /* 'd' */
    {0x38,0x54,0x54,0x54,0x18}, /* 'e' */
    {0x08,0x7E,0x09,0x01,0x02}, /* 'f' */
    {0x0C,0x52,0x52,0x52,0x3E}, /* 'g' */
    {0x7F,0x08,0x04,0x04,0x78}, /* 'h' */
    {0x00,0x44,0x7D,0x40,0x00}, /* 'i' */
    {0x20,0x40,0x44,0x3D,0x00}, /* 'j' */
    {0x7F,0x10,0x28,0x44,0x00}, /* 'k' */
    {0x00,0x41,0x7F,0x40,0x00}, /* 'l' */
    {0x7C,0x04,0x18,0x04,0x78}, /* 'm' */
    {0x7C,0x08,0x04,0x04,0x78}, /* 'n' */
    {0x38,0x44,0x44,0x44,0x38}, /* 'o' */
    {0x7C,0x14,0x14,0x14,0x08}, /* 'p' */
    {0x08,0x14,0x14,0x18,0x7C}, /* 'q' */
    {0x7C,0x08,0x04,0x04,0x08}, /* 'r' */
    {0x48,0x54,0x54,0x54,0x20}, /* 's' */
    {0x04,0x3F,0x44,0x40,0x20}, /* 't' */
    {0x3C,0x40,0x40,0x20,0x7C}, /* 'u' */
    {0x1C,0x20,0x40,0x20,0x1C}, /* 'v' */
    {0x3C,0x40,0x30,0x40,0x3C}, /* 'w' */
    {0x44,0x28,0x10,0x28,0x44}, /* 'x' */
    {0x0C,0x50,0x50,0x50,0x3C}, /* 'y' */
    {0x44,0x64,0x54,0x4C,0x44}, /* 'z' */
    {0x00,0x08,0x36,0x41,0x00}, /* '{' */
    {0x00,0x00,0x7F,0x00,0x00}, /* '|' */
    {0x00,0x41,0x36,0x08,0x00}, /* '}' */
    {0x08,0x04,0x08,0x10,0x08}, /* '~' */
	{0x06,0x09,0x09,0x06,0x00}, /* '°' */
};

/* ── oled_cmd ────────────────────────────────────────────────────────────────
 * Send one SSD1306 command byte.
 * SSD1306 protocol: 0x00 = control byte meaning "command follows".
 * So every command is a 2-byte I2C write: [0x00, cmd].
 */
void oled_cmd(uint8_t cmd)
{
    uint8_t buf[2] = { 0x00, cmd };
    i2c_send(OLED_ADDR, buf, 2);
}

/* ── oled_init ───────────────────────────────────────────────────────────────
 * SSD1306 power-on and configuration sequence.
 */
void oled_init(void)
{
    for (volatile uint32_t i = 0; i < 150*1600; i++);  /* 150ms VCC settle */

    oled_cmd(0xAE);              /* display OFF — configure while off        */
    oled_cmd(0xD5); oled_cmd(0x80); /* clock / osc                           */
    oled_cmd(0xA8); oled_cmd(0x3F); /* multiplex = 64 rows                   */
    oled_cmd(0xD3); oled_cmd(0x00); /* display offset = 0                    */
    oled_cmd(0x40);                  /* start line = 0                       */
    oled_cmd(0x8D); oled_cmd(0x14); /* charge pump ON — required at 3.3V    */
    oled_cmd(0x20); oled_cmd(0x00); /* horizontal addressing mode            */
    oled_cmd(0xA1);                  /* segment remap                        */
    oled_cmd(0xC8);                  /* COM scan remap                       */
    oled_cmd(0xDA); oled_cmd(0x12); /* COM pins config                       */
    oled_cmd(0x81); oled_cmd(0xCF); /* contrast                              */
    oled_cmd(0xD9); oled_cmd(0xF1); /* pre-charge period                     */
    oled_cmd(0xDB); oled_cmd(0x40); /* VCOMH                                 */
    oled_cmd(0xA4);                  /* follow GDDRAM                        */
    oled_cmd(0xA6);                  /* normal display                       */
    oled_cmd(0x21); oled_cmd(0x00); oled_cmd(0x7F); /* col window 0-127     */
    oled_cmd(0x22); oled_cmd(0x00); oled_cmd(0x07); /* page window 0-7      */
    oled_cmd(0xAF);                  /* display ON — always last             */
}

/* ── oled_clear ──────────────────────────────────────────────────────────────
 * Zero the framebuffer. Call at the start of every frame.
 */
void oled_clear(void)
{
    fb[0] = 0x40;
    memset(fb + 1, 0, OLED_W * OLED_PAGES);
}

/* ── oled_set_pixel ──────────────────────────────────────────────────────────
 * Set or clear one pixel in the framebuffer.
 * x = 0..127, y = 0..63, on = 1 or 0
 */
void oled_set_pixel(int x, int y, int on)
{
    if ((unsigned)x >= OLED_W || (unsigned)y >= OLED_H) return;
    uint8_t *p = &fb[1 + (y >> 3) * OLED_W + x];
    if (on) *p |=  (1U << (y & 7));
    else    *p &= ~(1U << (y & 7));
}


void oled_draw_char(int x, int page, char c)
{
    uint8_t idx;
    if      (c == SYM_DEGREE)         idx = 95;
    else if (c >= 0x20 && c <= 0x7E)  idx = (uint8_t)(c - 0x20);
    else                              idx = (uint8_t)('?' - 0x20);

    const uint8_t *g = font[idx];
    for (int i = 0; i < 5 && (x + i) < OLED_W; i++)
        fb[1 + page * OLED_W + x + i] = g[i];
    if (x + 5 < OLED_W)
        fb[1 + page * OLED_W + x + 5] = 0;
}
void oled_print(int x, int page, const char *s)
{
    while (*s && x < OLED_W) {
        oled_draw_char(x, page, *s++);
        x += 6;
    }
}

uint8_t oled_is_busy(void)
{
    return dma_busy;
}
void oled_dma_complete(void)
{
    dma_busy = 0;
}
void oled_flush(void)
{
	if(dma_busy) return;
	dma_busy = 1;
    uint32_t t;

    /* Reset GDDRAM address window to full screen */
    oled_cmd(0x21); oled_cmd(0x00); oled_cmd(0x7F);  /* cols 0-127  */
    oled_cmd(0x22); oled_cmd(0x00); oled_cmd(0x07);  /* pages 0-7   */

    fb[0] = 0x40;   /* data mode control byte — must be first byte DMA sends */

    /* Recover if bus stuck */
    if (I2C1->SR2 & I2C_SR2_BUSY) {
        /* trigger reset via i2c layer indirectly — send dummy then recover */
        for (volatile int i = 0; i < 1600; i++);
    }

    /* START — DMA cannot generate this */
    I2C1->CR1 |= I2C_CR1_START;
    t = 50000; while (!(I2C1->SR1 & I2C_SR1_SB)   && --t);
    if (!t) return;

    /* Address — DMA cannot send this either */
    I2C1->DR = OLED_ADDR;
    t = 50000; while (!(I2C1->SR1 & I2C_SR1_ADDR) && --t);
    if (!t) { I2C1->CR1 |= I2C_CR1_STOP; return; }
    (void)I2C1->SR1; (void)I2C1->SR2;   /* clear ADDR — I2C now in TX state */

    /* DMA takes over — sends fb[0..1024] */
    oled_dma_send(fb, sizeof(fb));
}
